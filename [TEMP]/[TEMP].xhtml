<?xml version="1.0" encoding="utf-8"?>
<!--
                                                                                     
 h       t     t                ::       /     /                     t             / 
 h       t     t                ::      //    //                     t            // 
 h     ttttt ttttt ppppp sssss         //    //  y   y       sssss ttttt         //  
 hhhh    t     t   p   p s            //    //   y   y       s       t          //   
 h  hh   t     t   ppppp sssss       //    //    yyyyy       sssss   t         //    
 h   h   t     t   p         s  ::   /     /         y  ..       s   t    ..   /     
 h   h   t     t   p     sssss  ::   /     /     yyyyy  ..   sssss   t    ..   /     
                                                                                     
	<https://y.st./>
	Copyright © 2018 Alex Yst <mailto:copyright@y.st>

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org./licenses/>.
-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<base href="https://y.st./[TEMP]/[TEMP].xhtml"/>
		<title>UDP &lt;https://y.st./[TEMP]/[TEMP].xhtml&gt;</title>
		<link rel="icon" type="image/png" href="/link/CC_BY-SA_4.0/y.st./icon.png"/>
		<link rel="stylesheet" type="text/css" href="/link/main.css"/>
		<script type="text/javascript" src="/script/javascript.js"/>
		<meta name="viewport" content="width=device-width"/>
	</head>
	<body>
<nav>
</nav>
		<header>
			<h1><abbr title="User Datagram Protocol">UDP</abbr></h1>
			<p>Written in <span title="Communications and Networking">CS 2204</span> by <a href="https://y.st./">Alex Yst</a>, finalised on 2018-05-23</p>
		</header>
<h2>Fragmentation</h2>
<p>
	According to <abbr title="Request for Comments">RFC</abbr> 791, <abbr title="Internet Protocol">IP</abbr> packets may be fragmented, but the data contained in the payload can only be split on an eight-byte (sixty-four-bit) boundary (Information Sciences Institute, 1981).
	Headers from the initial packet are duplicated and included in all fragments, and sequence numbers (for reassembly) are added along with an identification field (to distinguish fragments of this packet from fragments of another).
</p>
<p>
	<abbr title="User Datagram Protocol">UDP</abbr> headers are eight bytes long (Dordal, 2014), and are part of the payload data as seen by <abbr title="Internet Protocol version Four">IPv4</abbr>.
	That makes our <abbr title="Internet Protocol version Four">IPv4</abbr> payload length 2008 bytes long.
	We&apos;re not given the size of the <abbr title="Internet Protocol version Four">IPv4</abbr> header used, and <abbr title="Internet Protocol version Four">IPv4</abbr> uses variable-width headers, unlike <abbr title="Internet Protocol version Six">IPv6</abbr>.
	Ignoring <abbr title="Internet Protocol version Four">IPv4</abbr> headers, a minimum of two fragments should be necessary; including maximum size headers, only two fragments should be needed as well.
	We can thus assume that a well-written implementation will fragment this packet into only two parts, but this is not strictly required; as many as 251 (2008 divided by 8) fragments are in fact possible.
	<abbr title="Request for Comments">RFC</abbr> 791 also makes no specification about along what lines fragmentation must occur, beyond specifying that it must be on an eight-byte boundary, making it implementation-dependant.
	It&apos;s also worth noting that packet reassembly doesn&apos;t occur at the other end of the Ethernet link, but rather, at the original packet&apos;s destination.
</p>
<h2>Problems with <abbr title="remote procedure call">RPC</abbr></h2>
<p>
	The first issue with <abbr title="remote procedure call">RPC</abbr> is that it must cache results on the server side in case they don&apos;t make it to the client.
	If the results make it, but the acknowledgement doesn&apos;t make it back to the server, the server may end up resending the results thinking the client never got them.
	If the client is no longer listening to for the reply, as it&apos;s already received it, this could lead to the server retransmitting repeatedly and will likely result in the results being cached indefinitely.
	This was such a big problem that Sun Microsystems went and developed an alternative version of <abbr title="remote procedure call">RPC</abbr> to get around the problem (Dordal, 2014).
</p>
<p>
	Another problem is <abbr title="remote procedure call">RPC</abbr> has no sense of sessions; it only has a single request, a single reply, and a single acknowledgement.
	While this is in fact it&apos;s strength, it&apos;s a big weakness as well.
	It means that neither the request nor the reply can exceed the limits of a single packet in length.
	For some applications, such as <abbr title="Domain Name System">DNS</abbr>, this is perfectly acceptable.
	That&apos;s more than enough space to get the job done.
	For other applications though, it makes <abbr title="remote procedure call">RPC</abbr> an invalid choice of transfer protocols.
	Imagine trying to download a live disk image for your favourite Linux distribution.
	With so much software and other data packed into it, the file size would exceed the limits of a single packet, probably by over a million fold.
	<abbr title="remote procedure call">RPC</abbr> simply can&apos;t handle that type of usage.
	Transfer of files, including multi-packet files, has been implemented.
	However, it&apos;s done by breaking the file into pieces and having the client request not the file, but a <strong>*specific chunk*</strong> of the file.
	Some types of long requests or replies can be broken down in a sensible way such as this, but not all can.
	Even for fragmented file transfer such as this, it doesn&apos;t allow for disk-level optimisations to be made, as each segment is transferred individually, and not within the context of the file as a whole.
</p>
<p>
	Lastly, <abbr title="remote procedure call">RPC</abbr> doesn&apos;t handle network congestion well.
	As a result, it works fine over a single <abbr title="local area network">LAN</abbr> and in a few other cases, but it for the most part doesn&apos;t function well over the greater Internet.
	That said, this problem hasn&apos;t stopped people from finding uses for it&apos;s use over the Internet.
	<abbr title="Domain Name System">DNS</abbr>, one of the most widely-used Internet services, even by people that have never even heard of <abbr title="Domain Name System">DNS</abbr>, is built on top of <abbr title="remote procedure call">RPC</abbr>.
</p>
<h2>Timestamping</h2>
<p>
	Timestamping is used by real-time applications so the receiver of the timestamped packet can determine the current relevancy of said packet.
	As the book says (Dordal, 2014), a packet that arrives late to a real-time application is the same as a packet that never arrived.
	There&apos;s a very short window in which the packet can be used, and data loss (such as would be caused by dropping the late-arriving packet) is more tolerable than late use of the packet&apos;s payload.
</p>
<h2><abbr title="User Datagram Protocol">UDP</abbr> versus raw <abbr title="Internet Protocol">IP</abbr> packets</h2>
<p>
	The main reason <abbr title="User Datagram Protocol">UDP</abbr> should be preferred over crafting raw <abbr title="Internet Protocol">IP</abbr> packets is the use of ports.
	If we were to build a hypothetical protocol which used raw <abbr title="Internet Protocol">IP</abbr> packets as its mode of communication, that protocol would tie up the machine&apos;s entire line.
	<abbr title="Transmission Control Protocol">TCP</abbr> wouldn&apos;t get through.
	<abbr title="User Datagram Protocol">UDP</abbr> wouldn&apos;t get through.
	Only one application could listen to incoming traffic, and that application would be getting <strong>*all*</strong> the traffic, trying to make sense of it.
	<abbr title="Transmission Control Protocol">TCP</abbr> and <abbr title="User Datagram Protocol">UDP</abbr> both include the concept of ports though.
	The operating system (or a process controlled by it) then acts as the single application able to listen on the line, intercepting all packets.
	From there, the <abbr title="operating system">OS</abbr> is able to determine which application (if any) should receive each packet based on whether <abbr title="Transmission Control Protocol">TCP</abbr> or <abbr title="User Datagram Protocol">UDP</abbr> was used, and what port the packet was sent to.
	Without this concept of ports, network communication becomes limited to only one process, so raw <abbr title="Internet Protocol">IP</abbr> should never be used by userland applications.
</p>
<h2>Cutting out round-trip delays</h2>
<p>
	The book doesn&apos;t seem to cover this question, but how does <abbr title="Quick User Datagram Protocol Internet Connections">QUIC</abbr> eliminate round trips and save time on <abbr title="Transport Layer Security">TLS</abbr> handshakes?
	It turns out that <abbr title="Quick User Datagram Protocol Internet Connections">QUIC</abbr> is able to make use of pre-shared keys for encryption (Thompson &amp; Hamilton, 2016).
	The first time <abbr title="Quick User Datagram Protocol Internet Connections">QUIC</abbr> is used to connect to a given server, no round trips can be eliminated.
	Everything must be done similarly to how it&apos;s done with <abbr title="Transport Layer Security">TLS</abbr> over <abbr title="Transmission Control Protocol">TCP</abbr>.
	However, when a <abbr title="Transport Layer Security">TLS</abbr> connection is torn down, the <abbr title="Transport Layer Security">TLS</abbr> connection is torn down with it.
	In <abbr title="Quick User Datagram Protocol Internet Connections">QUIC</abbr>, this is not the case, and future communications with that server may use the same keys obtained during the first connection, so round trips are saved because the handshake doesn&apos;t need to be performed this time.
</p>
<div class="APA_references">
	<h2>References:</h2>
	<p>
		Dordal, P. (2014). 11 UDP Transport - An Introduction to Computer Networks, edition 1.9.10. Retrieved from <a href="https://intronetworks.cs.luc.edu/current/html/udp.html"><code>https://intronetworks.cs.luc.edu/current/html/udp.html</code></a>
	</p>
	<p>
		Information Sciences Institute. (1981, September). RFC 791 - Internet Protocol. Retrieved from <a href="https://tools.ietf.org/html/rfc791#page-8"><code>https://tools.ietf.org/html/rfc791#page-8</code></a>
	</p>
	<p>
		Thompson, M., &amp; Hamilton, R. (2016, October 25). 2.1. Handshake Overview. Retrieved from <a href="https://tools.ietf.org/id/draft-thomson-quic-tls-01.html#rfc.section.2.1"><code>https://tools.ietf.org/id/draft-thomson-quic-tls-01.html#rfc.section.2.1</code></a>
	</p>
</div>
		<hr/>
		<p>
			Copyright © 2018 Alex Yst;
			You may modify and/or redistribute this document under the terms of the <a rel="license" href="/license/gpl-3.0-standalone.xhtml"><abbr title="GNU&apos;s Not Unix">GNU</abbr> <abbr title="General Public License version Three or later">GPLv3+</abbr></a>.
			If for some reason you would prefer to modify and/or distribute this document under other free copyleft terms, please ask me via email.
			My address is in the source comments near the top of this document.
			This license also applies to embedded content such as images.
			For more information on that, see <a href="/en/a/licensing.xhtml">licensing</a>.
		</p>
		<p>
			<abbr title="World Wide Web Consortium">W3C</abbr> standards are important.
			This document conforms to the <a href="https://validator.w3.org./nu/?doc=https%3A%2F%2Fy.st.%2F%5BTEMP%5D%2F%5BTEMP%5D.xhtml"><abbr title="Extensible Hypertext Markup Language">XHTML</abbr> 5.2</a> specification and uses style sheets that conform to the <a href="http://jigsaw.w3.org./css-validator/validator?uri=https%3A%2F%2Fy.st.%2F%5BTEMP%5D%2F%5BTEMP%5D.xhtml"><abbr title="Cascading Style Sheets">CSS</abbr>3</a> specification.
		</p>
	</body>
</html>

