<?xml version="1.0" encoding="utf-8"?>
<!--
                                                                                     
 h       t     t                ::       /     /                     t             / 
 h       t     t                ::      //    //                     t            // 
 h     ttttt ttttt ppppp sssss         //    //  y   y       sssss ttttt         //  
 hhhh    t     t   p   p s            //    //   y   y       s       t          //   
 h  hh   t     t   ppppp sssss       //    //    yyyyy       sssss   t         //    
 h   h   t     t   p         s  ::   /     /         y  ..       s   t    ..   /     
 h   h   t     t   p     sssss  ::   /     /     yyyyy  ..   sssss   t    ..   /     
                                                                                     
	<https://y.st./>
	Copyright © 2018 Alex Yst <mailto:copyright@y.st>

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org./licenses/>.
-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<base href="https://y.st./[TEMP]/[TEMP].xhtml"/>
		<title>Binary tree &lt;https://y.st./[TEMP]/[TEMP].xhtml&gt;</title>
		<link rel="icon" type="image/png" href="/link/CC_BY-SA_4.0/y.st./icon.png"/>
		<link rel="stylesheet" type="text/css" href="/link/main.css"/>
		<script type="text/javascript" src="/script/javascript.js"/>
		<meta name="viewport" content="width=device-width"/>
	</head>
	<body>
<nav>
</nav>
		<header>
			<h1>Binary tree</h1>
			<p>Written in <span title="Data Structures">CS 3303</span> by <a href="https://y.st./">Alexand(er|ra) Yst</a>, finalised on 2018-12-12</p>
		</header>
<section id="Unit4">
	<h2>Unit 4</h2>
	<p>
		Most of the section explaining the basics of binary trees was review, though I didn&apos;t know the links between noset in a tree are called &quot;edges&quot;.
		Full and complete binary trees are easy enough to understand.
		It&apos;s worth noting that a tree can be both full and complete, but that one does not imply the other.
		For example, a full tree may have leaves sticking out in odd spots, making it not complete.
		A complete tree is perfectly balanced (<strong>*maybe*</strong> that fact warrants a special name, but we already have a name for trees with that property: balanced), but there&apos;s potentially a branch with only one leaf node attached in the final layer, making it not complete.
	</p>
	<p>
		The book tells us that the number of leaves in a full binary tree is the same for all binary trees with the same number of branches.
		The wording was a bit odd though, so I thought it was saying that the number of leaves was equal to the number of branches.
		I knew that couldn&apos;t be right.
		In a full binary tree consisting of the branches making up one big chain, if there are n branches, there are <strong>*not*</strong> n leaves.
		There are n+1 leaves!
		I&apos;d just misunderstood though.
		All binary trees with n branches have the same number of leaves as other binary trees with n branches.
		As it&apos;s incredibly easy to prove that a continuous chain of branches will always have n+1 leaves in a full tree, we can therefore deduce that in a full tree of any configuration, there is one more leaf than there are branches.
	</p>
	<p>
		When the book moved on to discuss tree traversal, I immediately thought of inorder traversal.
		It seems like the most logical way to traverse the tree in the context of trying to preserve a relationship between the data points held in the tree.
		I&apos;d forgotten about preorder traversal and postorder traversal though.
		Both have their usefulness in preserving the relationship between nodes instead of the relationship between the data points, which can be useful as well.
		The section on where to put null tree checks was informative as well.
		It made it very clear why the checks need to be done on the incoming value, not the values about to be used to recursively call the traversal function.
		At least in Java, a variable&apos;s type doesn&apos;t protect against null values, so the function could easily be called on an empty tree even before recursion.
	</p>
	<p>
		I find the idea of using a separate node type for leaves as for branches to be bizarre.
		A leaf is defined by the fact that it has no children, not the fact that it&apos;s using a different node type.
		This separate node type prevents the adding of children later, meaning that if a node needs to no longer be a leaf node, it must be swapped out for a new branch-type node.
		Likewise, if a branch node has it&apos;s leaves removed, while there won&apos;t be a technical reason why the node needs to be swapped out, consistency dictates that we should probably swap it out for a leaf-type node.
		It&apos;s foreign to me too to think that the leaves might store different types of data than the branches.
		And in the context of Java, we&apos;d need to know ahead of time the data types associated with a node&apos;s methods.
		They&apos;d need to have the same parent class, meaning that they&apos;d need to return the same data types, regardless of what data type is stored internally.
	</p>
	<p>
		The book claims a binary tree can be implemented as an array.
		This removes all the overhead, or at least most of it.
		Unless the array is the perfect size for the data, which would prevent the adding of more data, there will be a little bit of overhead.
		However, there&apos;s something very important to note here: there&apos;s no tree structure.
		We can <strong>*emulate*</strong> a tree structure by performing a binary search on the array, but the array is in no way actually a binary tree.
		After all, a binary tree is defined by its structure.
		If there is no tree structure, there is no binary tree.
		That said, the book is trying to claim this is somehow a tree, and the assignment instructions specifically say we can build our implementation using an array, so I alomst took advantage of that option.
		Using an array, we know exactly how many &quot;levels&quot; our &quot;tree&quot; has, as well as see easily where in the &quot;tree&quot; each data point should belong to avoid adding another &quot;level&quot; to the &quot;tree&quot;.
		The easiest way to keep track of the unused positions in the array is to keep all the used positions clumped together on one end, and the unused positions clumped together on the other.
		<del>This doesn&apos;t make for a balanced &quot;tree&quot;, but as long as the array is always of the size necessary to implement the fewest number of &quot;levels&quot; the &quot;tree&quot; could have while still retaining all the data, the worst case in binary search is only equal to the worst case for a balanced tree.
		This worst case just comes up a little more often than it should.
		The main problem, instead, is insertion.
		Insertion becomes very inefficient.
		In the worst case, not only is the array already full, but the value inserted is at the beginning.
		The values from the old array must then be copied to a new array of size 2n-1, then all the values shifted by one in order to make room for the new value.
		In a &quot;tree&quot; implemented like this, just after an insertion that bumps up the array size, one of the &quot;root&quot;&apos;s &quot;children&quot; is &quot;empty&quot;.
		The &quot;root&quot; is the worst place to have &quot;empty&quot; &quot;children&quot;.</del>
		Still, since the topic for the week is binary trees, I decided to use a real binary tree in my assignment submission.
		<ins>A few hours after deciding not to use an array, I realised my array implementation wouldn&apos;t work anyway.
		It&apos;d result in &quot;nodes&quot; other than the &quot;root&quot; not having &quot;parents&quot; in some cases.
		All sorting efficiency I&apos;d been squeezing out of the array would actually break the &quot;tree structure&quot;.</ins>
	</p>
	<p>
		It looks like we&apos;re not going to be covering how to keep trees balanced as items are added to them this week, unfortunately.
		So the only real option is to deal with the random insertion order by having a naturally-growing tree, with branches and leaves in unpredictable places.
	</p>
	<p>
		Max-heaps and min-heaps are types of binary trees I&apos;ve never heard of.
		Normally, the value of each child of a binary tree has a different relationship with the parent.
		One child is greater, while the other is lesser.
		With a min- or max-heap though, both children have the <strong>*same*</strong> relationship with the parent though.
	</p>
	<p>
		Huffman coding trees are interesting.
		I&apos;d thought that schemes such as Unicode were inefficient because not all bit sequences are valid and the bit encodings of characters are of differing lengths.
		However, I now see it&apos;s a matter of optimising for use with certain characters.
		I guess <abbr title="American Standard Code for Information Interchange">ASCII</abbr> characters do tend to get used in a lot of languages, so having them represented by shorter byte sequences is useful.
	</p>
	<p>
		When building my code for the assignment, I ended up refactoring some stuff to make it more efficient before the first run.
		I didn&apos;t realise it, but I&apos;d left some code in place that was no longer valid.
		Jeliot complained about something being not implemented, but wouldn&apos;t tell me what, or even what line the problem was on.
		Worst of all, Jeliot kept highlighting a valid function call, making it look like that function was potentially not implemented.
		However, there was a compilation error whenever that function was renamed, meaning that Jeliot was in fact finding the function and did know it to be implemented.
		I finally broke down and started an Eclipse project to use Eclipse&apos;s debugger instead.
		Eclipse complained about having all the classes in the same file, but after sifting out those errors, I found the real problem reported: I was trying to examine an attribute of an integer, but integers aren&apos;t part of a class and don&apos;t have methods.
		Jeliot can&apos;t even report such a simple error with anything more specific than &quot;not impleented&quot;, nor can it even point to the correct line so I could find the problem myself.
		There was another error as well, where I accidentally tried to use <code>self</code> instead of <code>this</code> to get an object to reference itself.
		Eclipse too complained about that.
		When I tried to use Jeliot&apos;s search feature to find where I&apos;d done that, Jeliot couldn&apos;t even find the word <code>self</code>.
		Eclipse, of course, could, and I was able to use that to figure out where to look in the copy open in Jeliot.
		Jeliot couldn&apos;t even find a simple string in the source file.
		I swear, Jeliot is not a usable tool for development.
		The fact that you need to wait for Jeliot&apos;s curtain close animation before it&apos;ll let you touch the source code is also just plain idiotic.
		There&apos;s no need for that.
		I understand locking up during the opening animation, honestly.
		It buys time for compilation to complete.
		Locking up during the closing animation only serves to annoy though.
	</p>
	<p>
		Jeliot likewise isn&apos;t handling the scanner in the way I&apos;d expect.
		I set my code up to catch the exception I expected it to throw if the user entered non-numeric data.
		In fact, that exception was to be the signal that the user was done with data-entry.
		However, Jeliot simply didn&apos;t allow such data to be entered in the first place, so no exception could ever be thrown.
		I was going to test in Eclipse to see if this was Jeliot being idiotic again or if I just don&apos;t understand how to use the <code>nextInt()</code> method properly.
		However, transferring between Jeliot and Eclipse was too much of a bother at this point.
		Jeliot wants all the classes in a single file, while Eclipse won&apos;t run the code unless they&apos;re in separate files.
		Another odd quirk of Jeliot is that it doesn&apos;t seem to support the <code>close()</code> method of scanner objects, you you have to just leave them open.
		It also couldn&apos;t recognise the output of <code>next()</code> to be anything other than a generic object, so I couldn&apos;t pass it directly to another method.
		Instead, I had to declare a <code>String</code>-type variable, store the value there, then pass the variable into the method I needed the value passed into.
	</p>
	<p>
		Besides me, no student posted to the discussion board until the second-to-last day.
		I was starting to worry everyone had abandoned ship and I was the last student in the class!
		I mean, not literally, but it was a bit annoying to have to wait to get my own replies in.
		I typically make one reply per day in the combination of both my courses, and when other students wait until the last minute to post, I&apos;m stuck waiting until the last minute to reply.
	</p>
	<p>
		I took longer to complete the binary sorting tree assignment than I should have.
		Maybe stress had something to do with it, but I feel like I should have been able to complete it a few hours quicker than I did.
		As for grading last week&apos;s assignment, one of the other students mentioned in their write-up that they couldn&apos;t get Jeliot running.
		I wonder if they have a similar computer set-up as I do.
		For me, the provided instructions didn&apos;t work.
		I had to combine some ingenuity with some prior knowledge to get it running.
		Just in case, I left instructions to repeat what worked for me in my feedback notes, so hopefully they&apos;ll read and try that.
	</p>
</section>
		<hr/>
		<p>
			Copyright © 2018 Alex Yst;
			You may modify and/or redistribute this document under the terms of the <a rel="license" href="/license/gpl-3.0-standalone.xhtml"><abbr title="GNU&apos;s Not Unix">GNU</abbr> <abbr title="General Public License version Three or later">GPLv3+</abbr></a>.
			If for some reason you would prefer to modify and/or distribute this document under other free copyleft terms, please ask me via email.
			My address is in the source comments near the top of this document.
			This license also applies to embedded content such as images.
			For more information on that, see <a href="/en/a/licensing.xhtml">licensing</a>.
		</p>
		<p>
			<abbr title="World Wide Web Consortium">W3C</abbr> standards are important.
			This document conforms to the <a href="https://validator.w3.org./nu/?doc=https%3A%2F%2Fy.st.%2F%5BTEMP%5D%2F%5BTEMP%5D.xhtml"><abbr title="Extensible Hypertext Markup Language">XHTML</abbr> 5.2</a> specification and uses style sheets that conform to the <a href="http://jigsaw.w3.org./css-validator/validator?uri=https%3A%2F%2Fy.st.%2F%5BTEMP%5D%2F%5BTEMP%5D.xhtml"><abbr title="Cascading Style Sheets">CSS</abbr>3</a> specification.
		</p>
	</body>
</html>

