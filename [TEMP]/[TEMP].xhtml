<?xml version="1.0" encoding="utf-8"?>
<!--
                                                                                     
 h       t     t                ::       /     /                     t             / 
 h       t     t                ::      //    //                     t            // 
 h     ttttt ttttt ppppp sssss         //    //  y   y       sssss ttttt         //  
 hhhh    t     t   p   p s            //    //   y   y       s       t          //   
 h  hh   t     t   ppppp sssss       //    //    yyyyy       sssss   t         //    
 h   h   t     t   p         s  ::   /     /         y  ..       s   t    ..   /     
 h   h   t     t   p     sssss  ::   /     /     yyyyy  ..   sssss   t    ..   /     
                                                                                     
	<https://y.st./>
	Copyright © 2018 Alex Yst <mailto:copyright@y.st>

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org./licenses/>.
-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<base href="https://y.st./[TEMP]/[TEMP].xhtml"/>
		<title>Leadership, Entrepreneurship, and Strategy &lt;https://y.st./[TEMP]/[TEMP].xhtml&gt;</title>
		<link rel="icon" type="image/png" href="/link/CC_BY-SA_4.0/y.st./icon.png"/>
		<link rel="stylesheet" type="text/css" href="/link/main.css"/>
		<script type="text/javascript" src="/script/javascript.js"/>
		<meta name="viewport" content="width=device-width"/>
	</head>
	<body>
<nav>
</nav>
		<header>
			<h1>Leadership, Entrepreneurship, and Strategy</h1>
			<p>Written in <span title="Data Structures">CS 3303</span> by <a href="https://y.st./">Alexand(er|ra) Yst</a>, finalised on 2018-12-05</p>
		</header>
<section id="Unit3">
	<h2>Unit 3</h2>
	<p>
		It turns out the solution to last week&apos;s discussion exercise <strong>*was*</strong> in fact provided.
		Also, it seems I was the one wrong.
		At first, I still thoroughly disagreed with the solution provided.
		Simply put, we know how many times the inner loop will run, and it isn&apos;t n<sup>2</sup> times.
		However, I got something majorly wrong as well.
		In fact, how badly I got this wrong greatly exceeds how far the provided solution is from reality.
		I messed up the definition of a factorial.
		I was using addition instead of multiplication, and factorials are about multiplication.
		I guess now that I think on it though, the provided solution is exactly right.
		Basically, the solution should be O(n<sup>2</sup>/2).
		However, we drop constant terms such as divide-by-two, and that leaves us with the answer nearly everyone in the class besides me got.
		My bad.
	</p>
	<p>
		This week was all about lists, queues, and stacks.
		All three of these constructs are things I&apos;m already very familiar with.
		I use lists all the time, and I&apos;ve used queues on numerous occasions.
		As for stacks ...
		I can&apos;t remember any time I&apos;ve ever used a stack, aside from the calling stack.
		However, stacks aren&apos;t exactly a difficult concept to understand, and you usually learn about them when you learn about queues, so I&apos;ve known about them for years.
		They&apos;re just not something that tends to be useful in the type of code I write.
		Sometimes, I need to process things in the order they arrive, and other times, order simply doesn&apos;t matter.
		When order doesn&apos;t matter, I use queues because they&apos;re what I think to use first, and things have to be dealt with in <strong>*some*</strong> order.
	</p>
	<p>
		The book&apos;s choice to implement the concept of a current position in a list implementation seems rational, until you see what they use it for.
		It&apos;s the type of thing you could use for iteration over a list, so it seems like a valid feature.
		However, they instead use it for rearranging lists.
		For example, the method that moves something to the beginning of the list takes the item in the current position and moves it.
		That means you need to set the current position, then perform the move.
		Why not just have the moving method take the current position, as represented by an integer, as a parameter?
		That&apos;d be a lot easier to use in practice.
		The book&apos;s implementation also uses the current position for insertion and deletion.
		Again, pass the position into those methods as an argument.
		You really only need the current position for the <code>next()</code> and <code>prev()</code> methods.
	</p>
	<p>
		The current position concept for use in additions, deletions, and access begins to make more sense when looking at linked lists, as opposed to array-powered lists, until you realise that this is still an <abbr title="application programming interface">API</abbr> failure; a problem in the interface.
		As the book discussed, it&apos;s important to be able to access <strong>*any*</strong> element of the list.
		This includes items we&apos;re not currently pointing at.
		Without random access, a list doesn&apos;t function as a proper list.
		This makes linked lists unsuitable for use in implementing lists.
		They can still be used for list implementations if you abstract away the inability to access random elements, though they&apos;re pretty slow for that kind of use.
		Linked lists are much more suited to things such as queues and stacks, where random access is neither needed nor permitted.
	</p>
	<p>
		The idea of a free list is interesting.
		It&apos;s not something I would have thought of, myself.
		It trades space for time, by not actually deleting old nodes, as it&apos;s computationally expensive to generate new nodes.
		So old nodes get saved and recycled.
		The drawback is, of course, that the size needed to store the list never shrinks.
		It can only grow.
		Well, the total space used by all the linked lists of a specific type can only grow.
		The linked lists are able to share a free list, after all.
	</p>
	<p>
		The book started out saying an array-based stack could use either end of the array as the top.
		I immediately thought that would be a bad idea.
		You shouldn&apos;t use index zero as the top, as it&apos;d mean always copying all the other elements for both pushes and pops.
		What do you gain from using that end?
		But then the book covered how bad of an idea that is, so the book and I were on the same page again.
	</p>
	<p>
		As a side note, I liked how the book mentioned that some problems require recursion &quot;or some approximation of recursion&quot;.
		I used to think some problems couldn&apos;t be solved without recursion, but the thing is, you can always approximate recursion.
		Computers can&apos;t actually handle recursion by default.
		Instead, operating system designers approximate recursion, which then the system and other programs use.
		If recursion can be built fro non-recursion, recursion can&apos;t be a basic building block.
		It can in fact be approximated and imitated.
	</p>
	<p>
		Just like I don&apos;t think linked lists make good list implementations, I didn&apos;t think arrays make good queue implementations.
		You need to keep shifting elements, which is inefficient.
		A linked list is pretty much the only good way to build a queue.
		The concept of not keeping the enqueued items on one end of the array is interesting though, ans certainly would help to lessen the problem.
		At least that way, only some enqueue operations would require moving any items.
		But then, the book continued, and explained circular queue implementations.
		That&apos;s actually rather clever!
		I believe a circular queue implementation removes all arguments I have against using an array as a queue.
	</p>
	<p>
		The book&apos;s take on dictionaries is that a key from a key/value pair duplicates a part of the value&apos;s record.
		But why does this necessarily need to be the case?
		Personally, when I implement dictionaries, I omit the key from the record in the value.
		For example, if I was storing employee records and the keys were the employee <abbr title="identification">ID</abbr> numbers, the records in the values would <strong>*not*</strong> include these <abbr title="identification">ID</abbr> numbers.
	</p>
	<p>
		It seems we&apos;re using Jeliot to develop Java code in this course.
		This will be the third Java course I&apos;ve taken at this school, and in each course, we&apos;ve used an entirely different <abbr title="integrated development environment">IDE</abbr>, for no apparent reason.
		It&apos;d be nice if the school was more consistent between courses.
		At least Jeliot is under a free license.
		I don&apos;t run proprietary software on my computer, so if Jeliot was under a proprietary license, I&apos;d be stuck on a different <abbr title="integrated development environment">IDE</abbr> than the rest of the class, and that might interfere with communication and assignment completion.
		Anyway, Jeliot didn&apos;t seem to want to run from the <code>.jnlp</code> file the assignment instructions linked to.
		What even <strong>*is*</strong> a <code>.jnlp</code> file?
		The software website also offered a basic <abbr title="Java Archive">JAR</abbr> file though, and that runs just fine.
	</p>
	<p>
		The first thing I noticed about Jeliot was the large, blank section and the tiny code section.
		After that, I noticed you can&apos;t see the white space by default, and that Jeliot uses spaces for indention by default.
		Ew.
		After replacing the spaces with proper tab characters, I looked for a setting to make white space visible, but found no such option.
		In fact, Jeliot doesn&apos;t seem to have many options at all.
		This certainly isn&apos;t an editor I&apos;d ever choose, but it&apos;s ... usable.
		Or so I thought.
		I wrote up most of the program we need for the week&apos;s assignment, then saved and closed it.
		When I reopened the program and loaded the code, I found every last one of my tab characters had been converted into spaces.
		Using spaces for indention is not proper coding style, and I will not write ugly code.
		I&apos;ve switched to my usual code editor, Geany, which doesn&apos;t have Java-specific functionality.
		(It&apos;s a text and code editor, and not an <abbr title="integrated development environment">IDE</abbr>.)
		I could of course use Eclipse, but that <abbr title="integrated development environment">IDE</abbr> requires setup of entire project directories just to write one Java file.
		From this point forward, I&apos;ll be writing my code in Geany, then pasting it into Jeliot for error-checking.
		I&apos;ll be submitting my Geany version though, which uses proper indentation.
	</p>
	<p>
		Building linked lists really isn&apos;t hard, so the assignment this week was a breeze.
		I think I&apos;ve done it before in another course, though I can&apos;t say for sure.
		I&apos;d check my personal records, but the university is censoring my main method of accessing them right now.
		Trying to search through my old work without the main access method is unnecessarily cumbersome, so I tend not to do it.
	</p>
	<p>
		For the most part, the discussion this week was just a retelling of the week&apos;s material.
		That&apos;s how it tends to be in the discussion forum.
		Sometimes, someone will come up with a gem we can all learn from, but usually, the discussion boards are just a thing that forces me to complete the reading material quicker than I&apos;d like to, to make sure I keep my posts released on schedule.
	</p>
</section>
		<hr/>
		<p>
			Copyright © 2018 Alex Yst;
			You may modify and/or redistribute this document under the terms of the <a rel="license" href="/license/gpl-3.0-standalone.xhtml"><abbr title="GNU&apos;s Not Unix">GNU</abbr> <abbr title="General Public License version Three or later">GPLv3+</abbr></a>.
			If for some reason you would prefer to modify and/or distribute this document under other free copyleft terms, please ask me via email.
			My address is in the source comments near the top of this document.
			This license also applies to embedded content such as images.
			For more information on that, see <a href="/en/a/licensing.xhtml">licensing</a>.
		</p>
		<p>
			<abbr title="World Wide Web Consortium">W3C</abbr> standards are important.
			This document conforms to the <a href="https://validator.w3.org./nu/?doc=https%3A%2F%2Fy.st.%2F%5BTEMP%5D%2F%5BTEMP%5D.xhtml"><abbr title="Extensible Hypertext Markup Language">XHTML</abbr> 5.2</a> specification and uses style sheets that conform to the <a href="http://jigsaw.w3.org./css-validator/validator?uri=https%3A%2F%2Fy.st.%2F%5BTEMP%5D%2F%5BTEMP%5D.xhtml"><abbr title="Cascading Style Sheets">CSS</abbr>3</a> specification.
		</p>
	</body>
</html>

