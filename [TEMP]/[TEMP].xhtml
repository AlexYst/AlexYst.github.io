<?xml version="1.0" encoding="utf-8"?>
<!--
                                                                                     
 h       t     t                ::       /     /                     t             / 
 h       t     t                ::      //    //                     t            // 
 h     ttttt ttttt ppppp sssss         //    //  y   y       sssss ttttt         //  
 hhhh    t     t   p   p s            //    //   y   y       s       t          //   
 h  hh   t     t   ppppp sssss       //    //    yyyyy       sssss   t         //    
 h   h   t     t   p         s  ::   /     /         y  ..       s   t    ..   /     
 h   h   t     t   p     sssss  ::   /     /     yyyyy  ..   sssss   t    ..   /     
                                                                                     
	<https://y.st./>
	Copyright © 2019 Alex Yst <mailto:copyright@y.st>

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org./licenses/>.
-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<base href="https://y.st./[TEMP]/[TEMP].xhtml"/>
		<title>Learning Journal &lt;https://y.st./[TEMP]/[TEMP].xhtml&gt;</title>
		<link rel="icon" type="image/png" href="/link/CC_BY-SA_4.0/y.st./icon.png"/>
		<link rel="stylesheet" type="text/css" href="/link/main.css"/>
		<script type="text/javascript" src="/script/javascript.js"/>
		<meta name="viewport" content="width=device-width"/>
	</head>
	<body>
<nav>
</nav>
		<header>
			<h1>Learning Journal</h1>
			<p>CS 4406: Computer Graphics</p>
		</header>
<section id="Unit1">
	<h2>Unit 1</h2>
	<p>
		The reading assignment for the week was as follows:
	</p>
	<ul>
		<li>
			<a href="https://math.hws.edu/graphicsbook/c1/index.html">Introduction to Computer Graphics, Chapter 1 -- Introduction</a>
		</li>
		<li>
			<a href="https://math.hws.edu/graphicsbook/c5/index.html">Introduction to Computer Graphics, Chapter 5 -- Three.js: A 3D Scene Graph API</a>
		</li>
		<li>
			<a href="https://people.csail.mit.edu/fredo/Depiction/1_Introduction/reviewGraphics.pdf">A Short Review of Computer Graphics.PDF - reviewGraphics.pdf</a>
		</li>
		<li>
			<a href="https://www.cs.csustan.edu/~rsc/NSF/Notes.pdf">Notes.pdf</a>: Chapter 0 and Chapter 1
		</li>
	</ul>
	<p>
		Seeing that the Introduction to Computer Graphics textbook focusses on <abbr title="three-dimensional">3D</abbr> graphics piqued my interest.
		When I signed up for this course, I was hoping to learn how to better create <abbr title="two-dimensional">2D</abbr> graphics, a skill I&apos;d use on my website, for creating game graphics, and perhaps more.
		Working with <abbr title="three-dimensional">3D</abbr> graphics should be pretty interesting though.
		In the end, as the textbook says, the end result of <abbr title="three-dimensional">3D</abbr> graphics editing is a <abbr title="two-dimensional">2D</abbr> image.
		I didn&apos;t think I could use that sort of thing much in the type of game I need images for, but I should be able to get even better-looking Web graphics using <abbr title="three-dimensional">3D</abbr> methods.
		As I read on, I found we were discussing terminology I&apos;d seen in Blender when trying to create a <abbr title="three-dimensional">3D</abbr> model though.
		I&apos;m starting to get into some basic modelling in the game I work with, so what we learn in this course may help with my game graphics after all, just not the part I&apos;d thought about as graphics.
	</p>
	<p>
		The term &quot;frame buffer&quot; was new to me, but the concept wasn&apos;t.
		I was already aware that the colour values for the image on-screen was stored in some block of memory, and that changes made to that block of memory cause changes on the monitor without need to recalculate every single pixel.
		You can even see side effects of that system when things go wrong.
		For example, Firefox locks up on me sometimes.
		When it does, all Firefox windows stop calculating values for their pixels (aside from the pixels of the window border, which are handled by the window manager instead of Firefox itself), and these windows begin to capture the output of whatever was in their place previously.
		For example, if I minimise the window to reveal the windows behind it, then unminimise the malfunctioning Firefox window, the window boarder gets drawn, but the inner pixels of the window don&apos;t change, so I see a still frame of the windows that were behind the Firefox window before I brought it back up.
		Or I can drag a smaller window across the malfunctioning Firefox window and it&apos;ll leave a trail.
		All of this is because Firefox isn&apos;t updating the values in the frame buffer that it&apos;s responsible for, so those valuse remain at whatever another process last set them to.
	</p>
	<p>
		I was also aware of the term &quot;raster graphics&quot;, and know the difference between raster graphics and vector graphics, though I wasn&apos;t aware the term was a legacy term from the vacuum tube days.
		I&apos;ve never managed to figure out how to properly edit vector graphics in an editing program though.
		I manage to make use of the <abbr title="GNU Image Manipulation Program">GIMP</abbr> reasonably well, but I can&apos;t get the first shape into place in Inkscape.
		The best I&apos;ve managed to do is compose and edit the <abbr title="Extensible Markup Language">XML</abbr> of <abbr title="Scalable Vector Graphics">SVG</abbr> files in a code editor, using an image viewer to check the results so as to know what to adjust.
		It&apos;s a bit of a pain, actually.
		I was also already aware of the difference between lossy and lossless compression.
		I&apos;ve never liked the idea of lossy compression, but it does drastically cut down the file size of my photographs.
	</p>
	<p>
		On some level, I knew enough about <abbr title="three-dimensional">3D</abbr> graphics to know that they&apos;re created using <abbr title="two-dimensional">2D</abbr> shapes in a <abbr title="three-dimensional">3D</abbr> space.
		I knew they weren&apos;t generated using voxels, the <abbr title="three-dimensional">3D</abbr> equivalent of pixels.
		It hadn&apos;t occurred to me that this makes them very similar to vector graphics though.
		I have far too little experience with both vector graphics and <abbr title="three-dimensional">3D</abbr> graphics to have notice such a conclusion.
	</p>
	<p>
		The textbook explained that shaders are small programs sent to the <abbr title="graphics processing unit">GPU</abbr>, and that they don&apos;t always have anything to do with shading.
		That explains a lot in the game I work with.
		The developers added several features that they called shaders, but some of them can&apos;t even be remotely attached to the idea of shading.
		For example, one of them causes certain images to be displaced, and another couple case objects to move around visually.
		These features are probably implemented using <abbr title="graphics processing unit">GPU</abbr> shaders, so the developers are calling them shaders.
	</p>
	<p>
		I couldn&apos;t follow a lot of what the material on <code>three.js</code> was saying.
		It was a bit above my head.
		One thing I did understand though was how the faces in a <code>three.js</code> model don&apos;t specify the coordinates of their vertices directly, but instead specify where those vertices lie in the vertex array.
		That seems rather useful.
		I mean, it obviously means more overhead, but it also means more consistency.
		If a vertex gets moved, all faces using that vertex are essentially automatically updated.
		Or more accurately, the faces don&apos;t even <strong>*need*</strong> to be updated.
	</p>
	<p>
		The short review of computer graphics claimed purple to be at (255, 0, 255).
		That is definitely not purple.
		That&apos;s pure magenta, one of the eight most extreme colours; the others being black, white, red, blue, green, yellow, and cyan.
		There&apos;s some variance as to where people draw the lines between colour labels, but there&apos;s no mistaking what colours are at positions with all colour channels each set to either zero or two fifty-five.
		If you&apos;re working with graphics, you should know these eight basic colours.
	</p>
	<p>
		At first, I liked how the textbook is sensible enough to start at the beginning when numbering its chapters; which is to say, it starts at chapter zero instead of just skipping over it like most books, textbook or otherwise.
		However, it seems to only even call it chapter zero in some contexts, and not label it as even being a chapter in others, such as the table of context.
		It&apos;s sort of treating zero as less than a number.
		That&apos;s a let-down.
	</p>
	<p>
		The <abbr title="three-dimensional">3D</abbr> eye coordinate system seems bizarre.
		If I&apos;m understanding it correctly, instead of moving the camera, you move everything <strong>*except*</strong> the camera as a way to simulate camera movement.
		That seems rather complicated compared to just moving one object, the camera itself.
	</p>
	<p>
		The concept of parallel and perspective viewing volumes is interesting.
		With how complicated <abbr title="three-dimensional">3D</abbr> graphics rendering seems to be, I hadn&apos;t even considered something as simple as parallel viewing volume.
		I just sort of assumed that you always had to calculate trajectories from objects to the viewing point, which makes the image more realistic, but also more complicated to produce.
		It seems that&apos;s actually optional though, and can be done depending on what sort of effect you&apos;re going for.
	</p>
	<p>
		The section on converting coordinates from the eye space to the display space was enlightening.
		It hadn&apos;t occurred to me that the eye space uses floats instead of integers for its coordinate system.
		I should have realised though.
		I really don&apos;t know how to make much work in Blender yet, but I&apos;ve worked with it a little bit.
		I managed to make a cube and get it properly sized and textured for what I needed.
		That&apos;s the extent of what I&apos;ve done in Blender.
		However, that little bit should have been enough to show me that the coordinate system used was in floats.
		I mean, I had to get the cube&apos;s side length to <code>1.28</code> before it came out right, and that&apos;s clearly not an integer.
		The eye space is an intermediate step between the world space and the <abbr title="two-dimensional">2D</abbr> image, so there&apos;s no reason for it to jump immediately to integer coordinates.
		If it did, it really wouldn&apos;t be any different than the final <abbr title="two-dimensional">2D</abbr> image&apos;s coordinate space and could simply be skipped.
	</p>
	<p>
		If we&apos;re going to be working the way the textbook describes, we&apos;ve going to be defining callbacks to do our work instead of doing it directly.
		I&apos;m well familiar with using callbacks, but it&apos;s surprising that we&apos;d be handling graphics this way, if this course is at all what I thought it was before I registered.
		I thought we were generating graphics, such as <abbr title="Portable Network Graphic">PNG</abbr> files.
		If we&apos;re instead creating interactive scenes, that&apos;s an entirely different situation, though callbacks would certainly make the most sense in such an environment.
	</p>
	<p>
		I thought that transforming the world space to convert from world coordinates to eye coordinates would be very complex.
		The textbook did a great job of explaining just how simple the calculations are though.
		At least, when dealing with an orthographical view, these calculations are extremely simple.
		You just move the world using the reverse path in which you moved the eye, setting the eye back into the default position in the process (as moving the world moves the objects in the world, such as the eye itself).
		The world thus becomes eye-centric.
		Perspective views perform further calculations that are a little more complex.
		You basically divide a point&apos;s <var>x</var> and <var>y</var> values by their <var>z</var> value to find where on the <abbr title="two-dimensional">2D</abbr> image space they project to.
		It seems simple except when I try to think about it too hard, at which point I start looking for some complex way to determine which otherwise-visible points are ignored because they&apos;re obscured by closer points.
		The obvious answer though is to render everything, and when it comes to projecting to the <abbr title="two-dimensional">2D</abbr> space, only write the colour of the relevant pixel according to the point with the <var>z</var> value closest to zero.
		It&apos;s a bit difficult for me to keep in mind that you can compare all the objects; you don&apos;t have to take a pixel and use it to calculate the one and only object it can see, then deal exclusively with that object.
		Rendering isn&apos;t a lookup operation.
	</p>
	<p>
		I recently learned the term &quot;z-fighting&quot;, and immediately recognised the visual effect from a particular game I play sometimes.
		However, I&apos;d never given much thought as to exactly why it occurs.
		The textbook gave an excellent explanation though.
		Items occupying the same space have the same <var>z</var> value, so when <code>z</code> values are compared to see if the current object is the closest thing to the camera, the points on both objects, when the object is drawn, register as the closest and are able to draw to the pixel.
		Next time the other equally-close object is drawn, it overwrites the value set by the previously-writing object, and the value of the pixel flips back and forth.
		Very interesting.
		The textbook framed it as a rounding issue when converting from continuous numbers to integers, but I don&apos;t think that&apos;s actually all that relevant to the issue.
		First, two objects could share exactly the same continuous number coordinates and that same effect would occur, with or without rounding.
		And secondly, the computer representation of a float has precision limitations too; there&apos;s not just integer size limits.
		So even if numbers remained as floats and were used that way, z-fighting would still occur.
		The rounding certainly makes z-fighting more likely to occur though.
	</p>
	<p>
		Reading through the assignment notes for the week, they said that we&apos;d be working with <code>three.js</code> because it doesn&apos;t require C++ and because it uses JavaScript and JavaScript is a language we&apos;ve worked with previously in this school&apos;s computer science curriculum.
		Um.
		What?
		I don&apos;t remember writing a <strong>*single*</strong> line of JavaScript at this school!
		I <a href="https://y.st./en/coursework/">archive</a> all my coursework though, so I went back and checked for the presence of JavaScript.
		Sure enough, there wasn&apos;t a single JavaScript file and not a single assignment that related to JavaScript in any way.
		And for context, I&apos;ve taken <strong>*both*</strong> Web programming courses already.
		They covered <abbr title="PHP: Hypertext Preprocessor">PHP</abbr>, <abbr title="Extensible Markup Language">XML</abbr>, <abbr title="Cascading Style Sheets">CSS</abbr>, and <abbr title="Hypertext Markup Language">HTML</abbr>, but not JavaScript.
		JavaScript had <strong>*not*</strong> been a part of this school&apos;s curriculum!
		I think we discussed JavaScript one week in one of the courses, but we definitely didn&apos;t learn it.
		After writing my thoughts on that though, I went back to reading the notes, and noticed the exact wording used.
		JavaScript was one of the languages &quot;introduced&quot;, not one of the languages &quot;learned&quot;.
		Okay, the notes had me there.
		We&apos;d definitely had JavaScript introduced to us in the form of telling us it existed, we just weren&apos;t taught how to actually use it.
		Just like we were introduced to the fact that Perl is a language, but again, not actually taught to make use of that language.
	</p>
	<p>
		I know some JavaScript from my own experiments outside the school, though JavaScript is a language I&apos;m very weak in.
		With access to the Internet at my fingertips though, I&apos;ll be able to look up the functions I need to make it through the class, I think.
		As for C++, I&apos;ve been hoping that C++ would be taught in a course I&apos;ll take in the future, though this seems to confirm that it won&apos;t be.
		It doesn&apos;t seem to be taught at this school, which is disappointing.
	</p>
	<p>
		The notes also say to get the code for the assignment from the &quot;Development Environment link in the course page&quot;.
		No such link exists on the course page.
		I checked the syllabus too, and it&apos;s not there.
		I ended up giving up and checking the assignment page, which I&apos;d put my reading of on hold to read the notes, as the assignment page told me to read the notes.
		The code was there, as it should be, and not through some separate &quot;Development Environment&quot; link.
	</p>
	<p>
		This seems to be the harder of my two courses this term.
		Some of the material seems to be above my head.
		Hopefully I can pull it together and figure out the material.
		I&apos;d love to learn how to generate and render <abbr title="three-dimensional">3D</abbr> scenes like this.
		Honestly, I don&apos;t see this stuff applying to a job I&apos;d be interested in, but off the clock, this seems like I could do a lot of things with it.
		It might even help me contribute to a project I like called Minetest.
		It&apos;s a <abbr title="three-dimensional">3D</abbr> game in which the world is made up of giant cubes.
		It uses the Irrlicht engine, mentioned briefly in one of the tables presented in the reading material, and relies on code contributions from the community for its continued development.
		I&apos;d love to be a part of what makes Minetest so great.
		The textbook also mentioned Blender.
		If I could even learn to use Blender properly, I could improve the plug-ins I write for Minetest, even if I didn&apos;t have the skills to contribute to the Minetest engine itself.
		In any case, I feel like there&apos;s a lot I could get from this course if I can wrap my head around the material better.
	</p>
</section>
<section id="Unit2">
	<h2>Unit 2</h2>
	<p>
		...
	</p>
</section>
<section id="Unit3">
	<h2>Unit 3</h2>
	<p>
		...
	</p>
</section>
<section id="Unit4">
	<h2>Unit 4</h2>
	<p>
		...
	</p>
</section>
<section id="Unit5">
	<h2>Unit 5</h2>
	<p>
		...
	</p>
</section>
<section id="Unit6">
	<h2>Unit 6</h2>
	<p>
		...
	</p>
</section>
<section id="Unit7">
	<h2>Unit 7</h2>
	<p>
		...
	</p>
</section>
<section id="Unit8">
	<h2>Unit 8</h2>
	<p>
		...
	</p>
</section>
		<hr/>
		<p>
			Copyright © 2019 Alex Yst;
			You may modify and/or redistribute this document under the terms of the <a rel="license" href="/license/gpl-3.0-standalone.xhtml"><abbr title="GNU&apos;s Not Unix">GNU</abbr> <abbr title="General Public License version Three or later">GPLv3+</abbr></a>.
			If for some reason you would prefer to modify and/or distribute this document under other free copyleft terms, please ask me via email.
			My address is in the source comments near the top of this document.
			This license also applies to embedded content such as images.
			For more information on that, see <a href="/en/a/licensing.xhtml">licensing</a>.
		</p>
		<p>
			<abbr title="World Wide Web Consortium">W3C</abbr> standards are important.
			This document conforms to the <a href="https://validator.w3.org./nu/?doc=https%3A%2F%2Fy.st.%2F%5BTEMP%5D%2F%5BTEMP%5D.xhtml"><abbr title="Extensible Hypertext Markup Language">XHTML</abbr> 5.2</a> specification and uses style sheets that conform to the <a href="http://jigsaw.w3.org./css-validator/validator?uri=https%3A%2F%2Fy.st.%2F%5BTEMP%5D%2F%5BTEMP%5D.xhtml"><abbr title="Cascading Style Sheets">CSS</abbr>3</a> specification.
		</p>
	</body>
</html>

