<?xml version="1.0" encoding="utf-8"?>
<!--
                                                                                     
 h       t     t                ::       /     /                     t             / 
 h       t     t                ::      //    //                     t            // 
 h     ttttt ttttt ppppp sssss         //    //  y   y       sssss ttttt         //  
 hhhh    t     t   p   p s            //    //   y   y       s       t          //   
 h  hh   t     t   ppppp sssss       //    //    yyyyy       sssss   t         //    
 h   h   t     t   p         s  ::   /     /         y  ..       s   t    ..   /     
 h   h   t     t   p     sssss  ::   /     /     yyyyy  ..   sssss   t    ..   /     
                                                                                     
	<https://y.st./>
	Copyright © 2019-2020 Alex Yst <mailto:copyright@y.st>

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program. If not, see <https://www.gnu.org./licenses/>.
-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<base href="https://y.st./[TEMP]/[TEMP].xhtml"/>
		<title>Learning Journal &lt;https://y.st./[TEMP]/[TEMP].xhtml&gt;</title>
		<link rel="icon" type="image/png" href="/link/CC_BY-SA_4.0/y.st./icon.png"/>
		<link rel="stylesheet" type="text/css" href="/link/main.css"/>
		<script type="text/javascript" src="/script/javascript.js"/>
		<meta name="viewport" content="width=device-width"/>
	</head>
	<body>
<nav>
</nav>
		<header>
			<h1>Learning Journal</h1>
			<p>CS 4403: Software Engineering 2</p>
		</header>
<section id="Unit1">
	<h2>Unit 1</h2>
	<h3>This week&apos;s activities</h3>
	<p>
		The reading assignment this week was the first four chapters from <a href="https://1drv.ms/b/s!Aq7znvDVvxSRh_E3Cmrm4O_vYvceZA?e=WkPFgb">The New Software Engineering</a>.
		Unfortunately, the site hosting The New Software Engineering - Saylor - is blocking me, so it seemed I wouldn&apos;t be able to read that.
		I tried searching the Web for an alternate host of the book, but had no luck.
		I found a couple sites that linked to the Saylor website or tried to sell me hard copies, but even if I had the money for a hard copy, it&apos;s a bit late to buy one now that class has started.
		It&apos;d take over a week to arrive, and we students weren&apos;t allowed to know what textbooks we&apos;d need until after class had started.
		We can&apos;t order the book and have it arrive in time, so getting a digital copy, which can arrive in seconds, is really the only option.
		Thankfully, another student uploaded the book elsewhere, so I was able to get the book, but one of my days off from work - one of my main study days - had passed before I could get my hands on it, which set me back.
	</p>
	<p>
		In addition to the reading assignment, we had the discussion assignment on data types and the written assignment on team management.
		The discussion assignment was confusing because the book never really discussed data types at all.
		I ended up mostly falling back on prior knowledge of data types, but that felt wrong.
		I mean, if we were discussing data types, surely there was something we were supposed to have learned about them this week.
		And I hadn&apos;t learned anything about them.
		It felt like I&apos;d missed something big.
		As for the written assignment, the scenario it introduced seemed so vague that I wasn&apos;t able to write anything concrete, which again seemed wrong.
		Is everything we&apos;re doing already going over my head?
		That&apos;s not a good sign.
		It&apos;s only the first week, and things are sure to get harder as we move on.
	</p>
	<p>
		I found a line in the introduction of the reading assignment hilarious.
		&quot;We take for granted the everyday convenience we gain from reservation, telephone, automated teller, and credit card authorization applications.&quot;
		I don&apos;t use technology to make reservations.
		The closest thing to reservations that I make are medical appointments.
		As far as I&apos;m aware, nowhere I have appointments at allow for making appointments via the Web, so I always go in person to make appointments.
		I guess recently, I also made an appointment to speak with my credit union&apos;s financial advisor, but I made the appointment with them via email.
		They may have used scheduling software on their end, but on my end, the only application used was my email client and the software running on the email server.
		I also don&apos;t use telephones.
		At all.
		I guess I have an old telephone in my entryway, but it&apos;s not plugged in and I have no telephone service, so the thing just sits there in a bag, not doing anything.
		I don&apos;t use automated teller machines or their software.
		I&apos;m not sure if my credit union even allows depositing of cheques such as pay cheques via the <abbr title="automated teller machine">ATM</abbr>.
		It&apos;s just easier for me to go inside and talk to a live, human teller.
		I guess I sometimes use a credit card.
		Do you know how many times I used a credit card last month though?
		Just once.
		It&apos;s certainly not an everyday convenience for me, though it does save me from having to make a trip to the credit union to withdraw money for my monthly medical treatments.
		For the most part though, I buy things with cold, hard cash.
		None of these types of applications, or even all of them combined, provide me anything close to the everyday convenience the textbook&apos;s author seems to think they provide everyone.
	</p>
	<p>
		The book makes a good point about people being resistant to change.
		That&apos;s one of the major weaknesses of our species.
		Our resistance to change holds us back.
		The worst part is that parents teach the old ways to children, so then the children get mostly stuck in that same rut.
		Each generation makes a little progress over the last one, but the fact that we hold so tightly to what we&apos;re used to keeps us from seeing the bigger picture and keeps us from getting anywhere quickly.
	</p>
	<p>
		The textbook tells us that another term for query applications is &quot;data analysis applications&quot;.
		That seems kind of odd.
		A query application returns the data you request of it.
		It doesn&apos;t do any analysis on that data.
		It seems odd that such applications would be considered to be data analysis applications.
		The book also makes the claim that declarative languages are easy to learn and use because you declare what needs to be done instead of how it needs to be done.
		I think it really depends on how you think though.
		For me, I find it difficult to use <abbr title="Structured Query Language">SQL</abbr>, a declarative language.
		However, I find imperative languages - languages in which you instruct the computer how to perform the task at hand - to be rather easy to work with.
		Admittedly, code in imperative languages is much more verbose, so it takes longer to write, but I find I actually understand what&apos;s going on better and don&apos;t need to look as many things up as I write it.
		When I write in <abbr title="Structured Query Language">SQL</abbr>, I find I have to look up pretty much everything I&apos;m working with, I frequently write the wrong query and get the wrong results, and even once I&apos;ve arrived at a working solution, I often don&apos;t really understand what my query is asking for when I go back and read my code later.
	</p>
	<p>
		The learn-as-you-go project life cycle was interesting to read about from a textbook.
		I mean, it&apos;s already how I work on my own projects, but it&apos;s a very amateurish way to do things, and I&apos;m surprised it&apos;s something that even has a name or that would be taught about in textbooks.
		As the textbook says, it&apos;s not fit for business organisations.
		That said, I highly doubt that I&apos;ll ever write software for a living.
		Programming is a hobby of mine, and will likely never be anything more.
		As such, it&apos;s the fun of it that matters in my case, not the professionalism.
		That said, I have to disagree with the book that the learn-as-you-go model is for the ignorant and the lazy.
		There are other reasons for this model too, just not really in business.
		Plenty of not-for-profit software is written this way, even though years upon years worth of effort goes into it.
		It&apos;s hard to be ignorant about the code you&apos;ve dedicated years of your life to.
		It&apos;s also hard to refer to such dedication as lazy.
		And when working on a given project isn&apos;t your day job, it can often be difficult to find time for formal life cycles.
		You either get in some time working on the actual project or you spend that time cutting through red tape.
		Skipping the red tape isn&apos;t always an act of ignorance or laziness.
		For larger projects though, an actual project life cycle is a better option, but this just isn&apos;t always the case, especially for smaller, one-developer projects.
	</p>
	<p>
		I didn&apos;t really understand the section on data types.
		It said it was going to introduce us to data types, but instead of introducing us to types of anything, it just talked about various characteristics data might have.
		It was like telling someone you&apos;d tell them about different types of fruit, but then just telling them that some fruit is red, some is green, some is round, and there&apos;s even some that&apos;s shaped like a star, but then not actually telling them about any specific type of fruit.
		Yes, fruit can have any of these characteristics and more, but you haven&apos;t really taught them about types of fruit at all.
	</p>
	<h3>Interviews and meetings</h3>
	<p>
		An interview is a group of a small number of people, gathered for a particular reason and for a specific amount of time.
		One-on-one information-gathering interviews are common, but aren&apos;t the only type of interview.
		Unlike interviews, meetings necessarily involve more than two people.
		They&apos;re still a gathering of people for a fixed period though, and can be used instead of interviews in many cases.
		In meetings, participants tend to discuss a small number of topics, and may or may not be gathering to reach some sort of consensus about something.
	</p>
	<p>
		Two purposes for which both meetings and interviews could be used would be to disseminate information amongst a small number of people or to gather information from a small number of people.
		What meetings and interviews excel at is getting information from someone to someone else.
		Two purposes for meetings but not interviews would be to come to a decision about something or to get information to a large number of people.
		Interviews necessarily don&apos;t involve many people or come to any decisions.
		Decision s may be made later based on information found during an interview, the the interview itself doesn&apos;t involve any decision-making.
		Two uses for interviews but not meetings would be to check out candidates for a job or to elicit information from someone in an unrelated company (such as a new reporter might do).
		Interviews are useful for their small group size.
		There&apos;s not a whole crowd trying to add their input or ask their questions, so you can keep the conversation on track better and more-easily make sure you get all the information you need.
	</p>
	<p>
		Structured interviews have a very specific set of questions to be asked.
		They&apos;re nice because the interviewer knows beforehand what to ask, and there&apos;s no real on-the-spot planning to anything.
		They can make sure to get the information that they held the interview to get.
		When holding multiple interviews with different people on the same topic, this also keeps all the interviewees on even footing, as they all get asked the same questions.
		This sort of fairness is important for things such as job interviews.
		However, this sort of interview is also rather rigid.
		If an interviewee&apos;s response sparks a new question in the interviewer&apos;s mind, they don&apos;t really have a way to just insert it.
		There&apos;s typically some sort of list of questions they&apos;re writing down answers to, with no good spot to add unrelated information and have that information be taken into account.
		Unstructured interviews allow for more open-ended questions and drawing new questions from the answers.
		There&apos;s no set questions to ask beforehand, and the interviewer can ask new or more-specific questions based on what the interviewee answers other questions with.
	</p>
	<h3>Open-ended and closed-ended questions</h3>
	<p>
		A closed-ended question is one in which there are a set number of answers to, and those answers tend to be rather short.
		For example, a yes-or-no question is as closed-ended as it gets.
		There&apos;s no room for other answers in most cases, though in some cases, a &quot;maybe&quot; or &quot;I don&apos;t know&quot; may be appropriate.
		That still leaves the number of answers available to be rather small.
		Multiple-choice questions are also closed-ended.
		With that sort of question, you can involve ranges in your answers, but you can&apos;t get specific points in those ranges.
		Open-ended questions, on the other hand, allow more free form responses.
		You could ask someone how their day went.
		You could ask someone their favourite colour.
		You could ask them when they plan to have their report on your desk, or what they have left to get done on their current project.
		In any of these cases, the person answering isn&apos;t limited to a set number of answers, and can reply in whatever way will get the necessary information across.
		Answers to open-ended questions tend to be more informative and help more with later planning, but it&apos;s harder to set courses of action beforehand based on potential responses and plan ahead before asking the questions.
	</p>
</section>
<section id="Unit2">
	<h2>Unit 2</h2>
	<h3>Activities for the week</h3>
	<p>
		The first task for the week was to grade the papers for last week.
		I usually grade those at my <abbr title="Linux User Group">LUG</abbr> meetings on Thursdays, and this week was no different.
		The first student&apos;s paper was okay.
		It wasn&apos;t bad, but nothing eye-catching.
		The second student wrote hardly anything, and didn&apos;t meet more than one of the requirements.
		The third student submitted a full-fledged paper though.
		I was impressed with that one.
	</p>
	<p>
		Next, I worked on the reading assignment:
	</p>
	<ul>
		<li>
			Chapter 5, Chapter 6, and one sub-subsection of Part 3 from <a href="https://1drv.ms/b/s!Aq7znvDVvxSRh_E3Cmrm4O_vYvceZA?e=WkPFgb">The New Software Engineering</a>
		</li>
		<li>
			<a href="https://files.ifi.uzh.ch/rerg/arvo/courses/seminar_ws02/reports/Seminar_4.pdf">COCOMOSpeech6.PDF - Seminar_4.pdf</a>
		</li>
		<li>
			<a href="https://my.uopeople.edu/pluginfile.php/590870/mod_book/chapter/208552/PERT%20CPM%20for%20Project%20Management.pdf">PERT CPM for Project Management - PERT CPM for Project Management.pdf</a>
		</li>
		<li>
			<a href="https://nptel.ac.in/courses/106105087/pdf/m11L28.pdf">Nptel, online courses and certification, Learn for free</a>
		</li>
		<li>
			<a href="https://nptel.ac.in/courses/106105087/pdf/m15L37.pdf">Nptel, online courses and certification, Learn for free</a>
		</li>
		<li>
			<a href="https://personal.utdallas.edu/~chung/RE/RE_chapters/Chapter%206.pdf">Chapter 6.pdf</a>
		</li>
		<li>
			<a href="https://www.math.csusb.edu/faculty/prakash/611/Project_Management.ppt.pdf">Project_Management.ppt - Project_Management.ppt.pdf</a>
		</li>
	</ul>
	<p>
		The Nptel documents had been replaced with pages asking that our bookmarks be replaced, and we had no way to know what page on the site we were to read, as only a link to the course index was provided on those pages.
	</p>
	<p>
		Finally, I submitted my discussion posts and essay for the week.
	</p>
	<p>
		The main thing I learned this week was how to use <abbr title="critical path method">CPM</abbr> diagrams to decide which components need to be worked on in what order.
		You can use them to easily find which chain of tasks is guaranteed to hold everything else up, and make sure always to be working on that chain.
		Other tasks can be worked on concurrently, but at no time should you not have someone working on that particular chain&apos;s tasks.
		Affinity analysis - a method of identifying like tasks so they can be combined - was also something we focused on.
	</p>
	<h3>Algorithmic, function point, and combined top-down, bottom-up estimating</h3>
	<p>
		Algorithmic estimation is exactly what it says on the tin: it&apos;s estimation using mathematical formulae.
		The advantages of this are rather obvious.
		First of all, maths are the same every time you plug the same numbers into the same equations.
		That means that the estimations provided by algorithmic estimation is repeatable.
		Every time you crunch the numbers, they&apos;ll turn up the same.
		Furthermore, computers are very good at processing algorithms.
		You can automate algorithmic estimation
		However, this method also assumes that things follow a continuous pattern; that the future will be the same as the past was.
		That&apos;s not always a valid assumption.
		This method also doesn&apos;t account for anomalous situations.
	</p>
	<p>
		Function point estimating uses repeatable and objective inputs, which helps with reliability.
		However, it too relies on history.
		You need to have recorded some history to calibrate it with, and if the future doesn&apos;t match the past, you again won&apos;t get accurate results.
		It also focuses on things external to the application, ignoring the internals.
	</p>
	<p>
		Combining top-down and bottom-up estimation is an option.
		Top-down estimation provides a focus on the system as a whole.
		It&apos;s also efficient, though if you&apos;re using it in combination with bottom-up estimation, you&apos;ve also got to take into account the resources that go into this second estimation method as well.
		Bottom-up estimation allows you to look at the details, instead of the system as a whole, giving you the opposite perspective that the top-down estimation gave you.
		It can also provide the stability that top-down estimation is unable to, and because individuals provide estimations on their own work, it offers a level of commitment from individuals that other estimations methods lack.
		The downsides of top-down estimation seem to be nullifies when performed alongside bottom-up estimation, and some of the negatives of bottom-up estimation too are compensated for by pairing it with top-down estimation.
		However, bottom-up estimation takes more effort than other estimations methods, and pairing it with a second estimation method means putting in even more effort on top of that.
		When you don&apos;t have the resources to put in the effort, this might not be the estimation method to choose.
	</p>
</section>
<section id="Unit3">
	<h2>Unit 3</h2>
	<p>
		...
	</p>
</section>
<section id="Unit4">
	<h2>Unit 4</h2>
	<p>
		...
	</p>
</section>
<section id="Unit5">
	<h2>Unit 5</h2>
	<p>
		...
	</p>
</section>
<section id="Unit6">
	<h2>Unit 6</h2>
	<p>
		...
	</p>
</section>
<section id="Unit7">
	<h2>Unit 7</h2>
	<p>
		...
	</p>
</section>
<section id="Unit8">
	<h2>Unit 8</h2>
	<p>
		...
	</p>
</section>
		<hr/>
		<p>
			Copyright © 2019-2020 Alex Yst;
			You may modify and/or redistribute this document under the terms of the <a rel="license" href="/license/gpl-3.0-standalone.xhtml"><abbr title="GNU&apos;s Not Unix">GNU</abbr> <abbr title="General Public License version Three or later">GPLv3+</abbr></a>.
			If for some reason you would prefer to modify and/or distribute this document under other free copyleft terms, please ask me via email.
			My address is in the source comments near the top of this document.
			This license also applies to embedded content such as images.
			For more information on that, see <a href="/en/a/licensing.xhtml">licensing</a>.
		</p>
		<p>
			<abbr title="World Wide Web Consortium">W3C</abbr> standards are important.
			This document conforms to the <a href="https://validator.w3.org./nu/?doc=https%3A%2F%2Fy.st.%2F%5BTEMP%5D%2F%5BTEMP%5D.xhtml"><abbr title="Extensible Hypertext Markup Language">XHTML</abbr> 5.2</a> specification and uses style sheets that conform to the <a href="http://jigsaw.w3.org./css-validator/validator?uri=https%3A%2F%2Fy.st.%2F%5BTEMP%5D%2F%5BTEMP%5D.xhtml"><abbr title="Cascading Style Sheets">CSS</abbr>3</a> specification.
		</p>
	</body>
</html>

